{
  "agent_name": "CTF_Challenge_Builder",
  "objective": "Automatically generate a fully functional vulnerable CTF challenge implementing the chain: Git directory leak → SQL Injection → JWT secret retrieval → JWT forgery → Admin-only command injection → Flag output.",

  "output_requirements": [
    "A runnable vulnerable web application including routes and logic.",
    "A real flag file accessible only via the final command injection.",
    "A .git folder containing a valid commit history and source code leaks.",
    "Database initialization logic with a config table holding the JWT secret.",
    "SQL injection endpoint that reveals database entries.",
    "JWT-based session authentication.",
    "Admin-only route with command injection vulnerability.",
    "Optional: docker-compose environment for hosting."
  ],

  "tech_stack": {
    "preferred": "Python Flask",
    "database": "SQLite (file-based for simplicity)",
    "on_disk_flag_path": "/flag.txt"
  },

  "global_files_to_generate": [
    "app.py",
    "challenge.db (auto-generated by init script)",
    "templates/* (HTML templates for login/search/admin)",
    "static/* (assets)",
    ".git directory (full history, including commit revealing SQLi and JWT usage)",
    "Dockerfile",
    "docker-compose.yml",
    "/flag.txt"
  ],

  "memory_schema": {
    "jwt_secret": null,
    "routes": [],
    "db_schema": [],
    "git_commits": [],
    "vulnerabilities_inserted": {
      "git_leak": false,
      "sqli": false,
      "jwt_secret_in_db": false,
      "admin_command_injection": false
    }
  },

  "build_sequence": [
    {
      "phase": "Project Setup",
      "tasks": [
        "Create project folder.",
        "Create empty Flask app with routing skeleton.",
        "Generate TEMPLATE HTML files for login, search, admin panel.",
        "Write placeholder Dockerfile and docker-compose.yml."
      ]
    },
    {
      "phase": "Flag Placement",
      "tasks": [
        "Add a flag 'Part 2: H4CK3R5_'.",
        "Write flag to /flag.txt.",
        "Ensure web application user account cannot access /flag.txt directly.",
        "Ensure only command injection can access /flag.txt."
      ]
    },
    {
      "phase": "Database Setup",
      "tasks": [
        "Initialize SQLite database.",
        "Create tables: users, posts, config.",
        "Insert sample users: 'alice' (user), 'admin' (admin).",
        "Insert example posts.",
        "Generate random 32-byte hex JWT secret.",
        "Store JWT secret into config table as key='jwt_secret'.",
        "Store schema and sample data in memory."
      ]
    },
    {
      "phase": "Implement Vulnerable Logic",
      "tasks": [
        {
          "vulnerability": "SQL Injection",
          "description": "Add /search?q=<input> route using unsafe string concatenation.",
          "code_pattern": "f\"SELECT id,title FROM posts WHERE title LIKE '%{q}%'\"",
          "set_flag": "vulnerabilities_inserted.sqli = true"
        },
        {
          "vulnerability": "JWT Auth System",
          "description": "Create login route, set JWT cookie using secret from DB.",
          "payload": {
            "user": "<username>",
            "role": "<admin|user>"
          },
          "set_flag": "vulnerabilities_inserted.jwt_secret_in_db = true"
        },
        {
          "vulnerability": "Admin Command Injection",
          "description": "Implement /admin/ping requiring admin role but executing shell=True command.",
          "code_pattern": "subprocess.check_output(f\"ping -c 1 {host}\", shell=True)",
          "set_flag": "vulnerabilities_inserted.admin_command_injection = true"
        }
      ]
    },
    {
      "phase": "Git Leak Creation",
      "tasks": [
        "Initialize a real git repository inside the project.",
        "Create multiple commits:",
        "  - Commit 1: Initial safe version.",
        "  - Commit 2: Add SQL logic (accidentally insecure).",
        "  - Commit 3: Move JWT secret from config file → database.",
        "  - Commit 4: Add admin tooling including dangerous ping interface.",
        "Stage the entire app but DO NOT add .gitignore for .git.",
        "Ensure .git folder remains accessible via web root.",
        "Mark vulnerabilities_inserted.git_leak = true."
      ]
    },
    {
      "phase": "Application Finalization",
      "tasks": [
        "Ensure Flask app binds to host 0.0.0.0.",
        "Ensure DEBUG=False.",
        "Generate README for challenge deployment.",
        "Verify chain: .git → SQLi → get secret → forge JWT → admin → RCE → flag. and create a solve script and a writeup",
        "Output the full project folder as final result."
      ]
    }
  ],

  "success_criteria": [
    "Running the Flask app produces a website with the following exploitable path:",
    "1. / .git is accessible",
    "2. /search SQL injection leaks config.jwt_secret",
    "3. JWT secret allows forging admin session",
    "4. /admin/ping?host=... executes OS commands",
    "5. Injecting `; cat /flag.txt` outputs the real flag",
    "Then 
  ],

}
